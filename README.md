% Punch Orders

# TODO

git log --pretty=oneline
git reset --soft HEAD~n
git reset --soft HEAD^1

This repo:

- [ ] design Ractors for dRuby and Bunny requests
- [ ] design clients scripts with a few concurrent threads
- [ ] desing domain events, `user.created|modified|removed`

# Purpose

The purposes of this project repository are:

1. To show how I see design of domain business logic with [Punch]()
2. To show how one can apply The Clean Architecture and DDD technics
3. To polish Punch and evolve my application design approach
4. To shows my applications design approach for potential customers

# Domain

Orders Domain consists of two actors, three entities, and ten services.

## Actors

- User
- Manager

## Entities

- User(name) @@todo suppose that users are inside Users domain :)
- Article(title, description, price, removed_at)
- Order(created_by, created_at, status, status_at, articles)

## Services

Shared:

- query articles(where, order, page_number, page_size)
- query orders(where, order, page_number, page_size)

User:

- create order(user_id, items)
- remove order(user_id, order_id)
- submit order(user_id, order_id)

Manager:

- create article(title, description, price)
- modify article(article_id, payload)
- remove article(article_id)
- accept order(order_id)
- cancel order(order_id)

## Plugins

- Store, Entity Store interface that provides 6 methods - `put`, `get`, `find`, `rm`, `key?`, `q`

# Apps (Faces)

The Orders Domain provides the following faces:

- dRuby
- Rack
- Rack face as pipeline of "authorize > produce > present"
- Bunny

Every Face:

- uses InMemoryStore implementation of Store Plugin
- uses shared set of entities presenters as JSON

## Design

Basically, every Face will consist of

- front object (stands for controller)
- set of actions to call domain services
- set of presenters for domain entities

> the last `app/rack2` utilize the straight pipeline of filters: Authorize >> Process >> Present

## Controller

A front object exists in a particular environment and provides request-response cycle:

- get an actor's request from the environment
- locate and then call requested domain service, adopting the service parameters from the environment
- translate the service response back into the environment and return the translated response to the actor.

## Action

An action locates requested domain service and translates provided parameters from the environment into the domain.

I started from a `Proxy` class that just wrap domain service call with arguments translation. And every actions inherited an particular domain service held domain parameters translation logic.

Later in `app/rack2` I abandoned the action in favor of the pipeline of `authorize >> produce >> present`

## Presenter

Presenter just presents an domain service response in the face environment. It should use only general objects types like strings, numbers, arrays, and hashes. That way it will be "naturally portable" for any environment.

A presenter actually presents domain entities, collections of domain entities, can casually some sort of metadata like `links` key for collections.

> All one could need there is Ruby Hash of strings, numbers, and arrays. It could be easily translated into JSON or like.

## Pagination

Querying big collection might cause sort of excessive service load and increase response time, so "face" should prevent such things by limiting number of record to return.

I chosen to provide a separate basic service for querying entities that provides `where`, `order`, `page_number`, and `page_size` input parameters; and this returns the queried collection with a meta information "is there more entities inside the store for `page_number`, `page_size`".

## Store Plugins

Store Plugin implemented as InMemoryStore which holds entities in memory as PORO, it

- provides basic immutability by deep_dup from Rails
- and locking mechanism based on MonitorMixin.

At the moment, this InMemoryStore implemented in a separate gem, that is not presented here. But such thing actually is easy do design oneself.

> Why InMemory? That way one could start clean without introducing any dependencies from storage technology at the beginning. It will serve perfectly for tests, could serve for MVP, etc. It will save one's time staying on PORO.

Later I designed the Store implementation for PostgreSQL database using Sequel gem. It's quite interesting and resembles sort of simplified ORM utilizing entities mappers and builders.

# Design Steps

At the beginning this repository was created using [Punch](https://github.com/nvoynov/punch) and the domain was designed using `Punch::DSL` in terms of Actors, Entities, and Services. Having the domain designed, all its source skeletons were generated by `PunchDomain` service.

The next step was manual design of the domain business logic with unit tests. In this process the store interface was established.

The following step was design particular faces - dRuby, Rack, and Bunny. At the beginning actions were generated from DSL created at the first place, but then those became rather generic and the generated code was replaced by crating actions just inside `Actions` module.

From the beginning I had InMemoryStore implementation, but it was connected only when I was testing face implementations calling for particular domain services.

And finally, I designed PostgreSQL Store that stores entities in separate tables and entity value object collections inside the entity table as PostgreSQL Arrays of JSONB. Database schema wad generated based on mappers using `#ddl` method.

The decision to postpone database design for the last thing was the right one.
